# (1) 원시 값과 객체의 비교

-   원시 타입과 객체 타입은 크게 세 가지 측면에서 다르다.

---

    🔴 원시타입🔴  🟠객체 타입🟠

🔴변경 불가능한 값 ▶️ 🟠변경 가능한 값

🔴원시값을 변수에 할당하면 변수에는 실제 값이 저장 ▶️ 🟠객체를 변수에 할당하면 변수에는 참조 값이 할당

🔴원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달 ( = 값에 의한 전달)
▶️ 🟠객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 ( = 참조에 의한 전달 )

---

# (2) 원시 값

## (2)-1 변경 불가능한 값

-   변수 : 값을 저장하기 위한 메모리 공간, 공간을 식별하기 위해 붙인 이름.
-   값 : 변수에 저장된 데이터, 즉 표현식이 생성된 결과.

—> ❗️`원시값이 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.`

<aside>
💡 값 자체는 변경 불가. 하지만 변수 값은 변경 가능 (변수 재할당을 통해 교체 가능)⚠️상수는 안됨!!

</aside>

---

🙌 원시값은 변경 불가능한 값, 즉 읽기 전용 값이다.

값을 할당한 변수 ▶️ 새로운 원시 값 재할당 ▶️ 새로운 메모리 공간 확보 ▶️ 재할당한 원시 값 저장

▶️ 변수는 새롭게 재할당한 원시 값을 가리킴. —> 이때 변수가 참조하던 메모리 공간의 주소가 바뀜❗️

👉🏻값의 이러한 특성을 **`불변성`** 이라 한다!!

—> `불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 방법이 없다.`

## (2)-2 문자열과 불변성

-   원시 값인 문자열은 다른 원시 값과 비교할 때 독특한 특징이 있다.

—> 1개의 문자는 2바이트의 메모리 공간에 저장된다!! 숫자 값은 1도, 1000000도 동일한 8바이트가 필요!

⁉️But, 문자열은(실제는 다름, 단순계산했을 때) 1개의 문자로 이뤄진 문자열은 2바이트,

10개의 문자열은 20바이트가 필요!

---

🙌 JS는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공.

—> js의 문자열은 원시 타입이며, 변경 불가능. ( = 문자열이 생성된 이후에는 변경 불가)

```jsx
let str = "Hello";
str = "world";
// 'Hello' 와 'world'는 모두 메모리에 존재. 문자열 'Hello' 에서 'world'로 변경시킴.
```

---

-   한번 생성된 문자열은 읽기 전용 값으로 변경 불가❌ —> `원시 값은 어떤 일이 있어도 불변.`

```jsx
let str = "string";

str[0] = "S";

console.log(str); // string
```

<aside>
💡 그러나 변수에 새로운 문자열을 재할당하는 것은 가능! 이는 기존 문자열 변경이 아닌, 새로운 문자열을 재할당하는 것!

</aside>

## (2)-3 값에 의한 전달

```jsx
let score = 80;
let copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80 --> 다른 메모리 공간에 저장된 별개의 값이리서!! 영향을 주지 않는다.
```

-   변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달.

—>❗️ `이를 **값에 의한 전달** 이라 한다!!`

---

# (3) 객체

-   프로퍼티 개수가 정해져 있지 않다. 또한 프로퍼티 값에도 제약 없음.
-   동적으로 추가되고 삭제할 수 있다.

—> 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

## (3)-1 변경 가능한 값

-   객체(참조) 타입의 값, 즉 객체는 변경 가능한 값이다.

```jsx
let person = {
    name: "Park",
};

console.log(person); // {name: "Park"}
```

→ 원시 값을 할당한 변수의 메모리 주소를 통해 메모리 공간에 접근하면 ▶️ 원시 값에 접근 가능.`(= **참조 값**에 접근 가능)`

= 즉, 원시 값을 할당한 변수는 `원시 값 자체를 값으로 갖는다.`

---

⁉️원시 값을 갖는 변수의 값은 재할당 외에는 변경 불가. **But,** `객체는 변경 가능함!!!`

즉 , 재할당 없이 프로퍼티를 동적으로 추가, 값 갱신, 프로퍼티 자체 삭제가 가능함!

<aside>
💡 **`객체`**는 메모리의 효율을 위해, 객체를 복사해 생성하는 비용을 절약하여 성능 향상을 위해 객체는 변경 가능한 값으로 설계가 되었다.  그러나!! **단점이 있는데, 객체는 여러 개의 식별자가 하나의 객체를 공유할 수 있다.**

</aside>

## (3)-2 참조에 의한 전달

```jsx
let person = {
    name: "Park",
};

// 참조 값을 복사(얕은 복사) copy와 person은 동일한 참조 값을 갖는다.
let copy = person;

// copy와 person은 동일한 객체를 참조
console.log(copy === person); // true

// copy를 통해 객체를 변경
copy.name = "Lee";

//person을 통해 객체를 변경
person.address = "Seoul";

//copy와 person은 동일한 객체를 가리킴
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
console.log(person); // {name: "Lee", address: "Seoul"}
console.log(copy); // {name: "Lee", address: "Seoul"}
```

-   객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면
    원본의 참조 값이 복사되어 전달된다. —> 이를 **`참조에 의한 전달`**이라 한다.!
-   **`“값에 의한 전달”`**과 **`“참조에 의한 전달”`**은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을
    복사해서 전달한다는 면에선 동일하다.
    ❗️다만 변수에 저장되어 있는 값이 원시 값이냐, 참조 값이냐의 차이만 있을 뿐.

👉🏻따라서 자바스크립트에는 “참조에 의한 전달”은 존재❌ → “값에 의한 전달”만이 존재⭕️
