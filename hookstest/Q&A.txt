Q1. 리액트를 사용하는 이유를 설명해보세요 (2가지 이상)
    - Virtual Dom 
    - components 


Q2. (Q1)을 통해 얻을 수 있는 장점은 무엇일까요?
    - 가상돔을 사용히면 랜더링이 필요없는 부분에서 랜더링을 할 필요가 없다.(필요한 부분만 렌더링)
    -  컴포넌트 설계를 잘 해두면 속도나 비용적으로 훨씬 좋다 세세하게 컴포넌트를 해두면 필요한 부분만 랜더링 하기 떄문에. 


Q3. 리액트가 가상 돔을 사용하는 이유는 무엇일까요?
    - 실제돔을 사용하면 사소한 변경사항에도 전체가 리랜더링 된다. 돔트리 전체가 다 랜더링이 되기 때문에 불필요한 비용과
      속도적인 측면에서 손해다. 즉 생산성 문제때문에 사용한다고 생각.
    

Q4. 리액트가 가상 돔과 돔 트리를 비교하여 바뀐 부분이 있다면 화면을 다시 그리는 행위를 무엇이라 할까요?
    - 리랜더링 


Q5. (Q3)의 행위를 통해 얻을 수 있는 이점은 무엇일까요?
    - Virtual Dom이 있기에 페이지가 바뀔때 마다 화면이 리랜더링 되지 않고, 바뀐 부분만 반영이 가능 하다. 
      이러한 부분때문에 리액트에서 컴포넌트 단위의 개발이 가능. 


Q6. (Q3)은 리액트에서 어느 순간에 실현될까요?
    - 리랜더링할때 실행이 된다. 스테이트를 변경하면 그때마다 가상돔을 실현한다.


Q7. 훅 함수는 왜 만들게 되었을까요?
    - 과거에는 함수형 컴포넌트에서 state와 라이프사이클 API를 사용할 수 없다는 단점이 있었는데, 
      이러한 단점은 앞서 언급한 것처럼 리액트 훅이 도입되면서 해결되었다.
    
    아래의 훅 함수는 각 언제 선언되어야 할까요?
    (1) useState - 스테이트를 변경할 곳이 있을때 ,상태관리를 할 때 선언
    (2) useRef - 리랜더링을 하지 않고 컴포넌트의 속성만 조회,수정시킬때 사용, 컴포넌트에 포커스를 위치 시킬때, 실제 돔에 접근하기 위해 사용
    (3) useEffect - 마운팅과 언마운팅 시킬때. render(Dom 구조가 모두 완료된 시점) 이후에 처리하는 함수. effect에 모아두었다가 처리. 
    (4) useCallback - 함수를 메모이제이션하기 위해 사용.
                      첫번째 인자로 넘어온 함수를, 두번째 인자로 넘어온 배열 내의 값이 변경될 때까지 저장해놓고 재사용할 수 있게 해줌.
    (5) useMemo - 처음에 계산된 결과값을 메모리에 저장해서 컴포넌트가 반복적으로 렌더링이 되어도
                  이전에 이미 계산된 결과 값을 메모리에서 꺼내와서 재사용 하기 위해 사용. 단, 꼭 필요할 때만 사용.


Q8. 커스텀 훅을 제작하면서 얻을 수 있는 이점은 무엇이고 어느 때 만들어야 할까요?
    - 코드, 로직의 간결해지고 가독성이 좋아진다
    - 필요없는 반복을 줄이고 재사용성을 높인다
    - 수정사항이 있을 시 커스텀 훅에서만 수정하면 되기 때문에 유지보수에 용이하다


Q9. 리액트로 프로젝트를 만들려고할 때 고려해야하는 사항들을 아는대로 작성해보세요 (3가지 이상)
    - 재사용성  
    - 랜더링 최적화
    - 유지보수


Q10. 만약 위의 질문에 모두 답을 했다면, 현재 부족한 것은 리액트가 아닌 자바스크립트 일 수 있습니다
    이전 풀어보았던 자바스크립트 API 문제 1~4와 board 문제를 현재 풀이할 수 있는지 확인해보세요
    
    react로 풀이를 한다고 가정했을 때와 (직접 바꿔보지는 말 것, 예제 문제와 유사)
    vanilla js(java script)로 풀이한다고 하였때 와의 차이점은 무엇일까요?

    * 위 문제를 받지 못한 수강생은 메일 전송 시 따로 첨부하여 송부

    - 가상돔을 사용 
    - 컴포넌트 단위로 쪼갤수 있는 것.
    

Q11. 리액트에서 컴포넌트를 나누는 기준은 어떻게 되어야할까요?
     또한, 이러한 관점은 개발자마다 다를 수 있는데 왜 그럴까요?

     - 
     - 
